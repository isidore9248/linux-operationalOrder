1、decltype
	decltype后的变量如果在括号内，如	decltype((i))	，
	则被推导为引用，必须初始化
2、命名空间：
	using namespace xxx	避免在h文件中使用
	如果需要使用string，可以使用using std::string
3、lambda表达式：
	见lambda.txt
4、bind
	A.占位符：在 functional 文件中，std::placeholders 命名空间下，
		_1 表示使用后面的第一个参数作为替代，类似于printf()函数中%d，
		(_1,_2)(1,2)-->(1,2)	和	(_2,_1)(1,2)-->(2,1)	表示的结果不同
5、智能指针：
	A.shared_ptr<...>内部有一个计数器，会计算每次指针改变时指向该地址的指针个数
		当cnt==0时，便会释放内存
	  unique_ptr<...>不支持拷贝，其
	B.不要用get初始化智能指针、为其赋值
	C.如果某个程序块抛出异常，智能指针可以释放，但普通指针不行
6、可变参数模板：
	在c++17以前需要用递归，并调用一个空模板
	c++17以后： 可以省略与之同名的空模板
		A.fold 折叠表达式：
				((cout << args << "  "), ..., (cout << endl));
				表示对于一个参数包，其会对第一个参数执行cout << args << "  "
				... 表示后续参数也会执行此语句
				对全部参数执行结束后会输出endl
		B.constexpr 条件编译：
				if constexpr (sizeof...(args) == 0)  
				当其满足条件时，就不会编译除了条件成立以外的并列语句
				但是其余的else 不能省略
7、右值引用：
	减少拷贝构造和拷贝赋值构造的调用花销，直接将堆区内存分配给需要使用的对象
	std::move()		将左值引用变为右值
	std::forward()	一般只在模板中使用，将传递的参数类型还原
8、纯虚函数：
	A.对于暂时无法实现功能的函数，可以声明为纯虚函数，留给派生类实现。
	B.一个类中有一个纯虚函数，该类即为抽象类，抽象类不能创建对象，即避免了对纯虚函数的调用
		但是可以声明一个野指针		如，Course *ptr;
	C.抽象类有子类的时候，除非子类重写全部的纯虚函数，否则子类本身也被自动被认为是抽象的。
9、抛出异常：
	A.catch只按照抛出的类型捕获。
	B.在catch时，可以只接收父类的引用，调用子类重写的虚函数(查看异常类型...)
	C.一个函数可以抛出的异常类型：
		func_rettype func_name (func_param) throw(error_type...)
		当在一个函数名后添加	throw(error_type...)	就确定了该函数可以抛出的异常类型
！！！！若throw()则不能抛出任何异常，若没有throw()则可以抛出任何类型的异常()---最常用
	D.在自定义异常类型时：
		a.继承标准异常 exception
		b.重写what函数，并在定义后 const throw() 防止父类在子类之前抛出标准异常
